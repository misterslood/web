<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collider</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
		
		 #homeButton {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px 20px;
		}
    </style>
</head>
<body>

	<a href="index.html" id="homeButton">Home</a>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create a plane
        const geometry = new THREE.PlaneGeometry(100, 100);
        const material = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
        const plane = new THREE.Mesh(geometry, material);
        scene.add(plane);
        plane.rotation.x = -Math.PI / 2;

        // Camera position for top-down view
        camera.position.set(0, 80, 0);
        camera.lookAt(0, 0, 0);

        // Raycaster and mouse setup
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const cubes = [];
        const spawnedPositions = new Map(); // Track spawned cube positions with timestamps
        const collisionCooldowns = new Map(); // Track cooldowns for collisions
        const collisionCounts = new Map(); // Track collision occurrences
        const maturationTimers = new Map(); // Track the maturation time for each cube
        const COLLISION_THRESHOLD = 100;
        const CULL_RADIUS = 5;
        const MATURATION_TIME = 1000; // 1 second maturation time before allowing cube collision spawns
        const MAX_COLLISIONS = 10; // Max number of collisions before culling a cube
        const NEARBY_RADIUS = 10; // Radius for checking nearby cubes

        // Function to generate a random color
        function getRandomColor() {
            return Math.random() * 0xffffff;
        }
		
        function getRandomLerpFactor() {
            return Math.random(); // (Math.random() * (max - min) + min)
        }
		
        // Function to blend two colors
        function blendColors(colorA, colorB) {
            const cA = new THREE.Color(colorA);
            const cB = new THREE.Color(colorB);
            const randomValue = Math.random() * 100;  // Random value between 0 and 100

            if (randomValue > 60) {
                // 25% chance to return color A
                return cA.getHex();
            } else if (randomValue < 40) {
                // 25% chance to return color B
                return cB.getHex();
            } else {
                // Between 25% and 75%, blend the colors
                const newrandomcolor = getRandomColor();
                return newrandomcolor;
            }
        }

        // Function to spawn a cube at a given position with a given color
        function spawnCubeAtPosition(position, color) {
            const posKey = `${position.x.toFixed(1)},${position.z.toFixed(1)}`;
            const currentTime = Date.now();
            if (spawnedPositions.has(posKey)) {
                if (currentTime - spawnedPositions.get(posKey) < 1000) return; // 1-second cooldown
            }

            const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
            const cubeMaterial = new THREE.MeshBasicMaterial({ color: color });
            const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);

            cube.position.set(position.x, 0.5, position.z);
            cube.userData.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.2,
                0,
                (Math.random() - 0.5) * 0.2
            );

            // Initialize collision counter for the cube
            cube.userData.collisionCount = 0;

            scene.add(cube);
            cubes.push(cube);
            spawnedPositions.set(posKey, currentTime);
            maturationTimers.set(cube.uuid, currentTime); // Set the maturation time when the cube spawns
        }

        // Function to remove cubes in a given radius from a position
        function cullCubes(position, radius) {
            for (let i = cubes.length - 1; i >= 0; i--) {
                if (cubes[i].position.distanceTo(position) < radius) {
                    scene.remove(cubes[i]);
                    cubes.splice(i, 1);
                }
            }
        }

        // Function to spawn a cube at the clicked location
        function spawnCube(intersect) {
            spawnCubeAtPosition(intersect.point, getRandomColor());
        }

        // Event listener for mouse clicks
        window.addEventListener("click", (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(plane);

            if (intersects.length > 0) {
                spawnCube(intersects[0]);
            }
        });

        // Helper function to track collisions between cubes
        function trackCollision(cubeA, cubeB) {
            const distance = cubeA.position.distanceTo(cubeB.position);
            if (distance < 1) {
                const currentTime = Date.now();
                const collisionKey = `${cubeA.uuid},${cubeB.uuid}`;

                if (collisionCooldowns.has(collisionKey) && currentTime - collisionCooldowns.get(collisionKey) < 1500) return;

                // Ensure both cubes are matured before triggering a collision spawn
                if (currentTime - maturationTimers.get(cubeA.uuid) < MATURATION_TIME || currentTime - maturationTimers.get(cubeB.uuid) < MATURATION_TIME) {
                    return; // Prevent spawning new cubes from immature cubes
                }

                // Check for nearby cubes within the radius
                let nearbyCubesCount = 0;
                for (let i = 0; i < cubes.length; i++) {
                    const otherCube = cubes[i];
                    if (otherCube !== cubeA && otherCube !== cubeB && otherCube.position.distanceTo(cubeA.position) < NEARBY_RADIUS) {
                        nearbyCubesCount++;
                    }
                }

                // If more than 1 other cubes exist within the radius, set max_collisions to 0
                if (nearbyCubesCount > 1) {
                    cubeA.userData.collisionCount = 10;
                    cubeB.userData.collisionCount = 10;
                }

                // Collision and response logic
                const collisionPoint = new THREE.Vector3().addVectors(cubeA.position, cubeB.position).multiplyScalar(0.5);
                const newColor = blendColors(cubeA.material.color.getHex(), cubeB.material.color.getHex());

                // Increase the collision count for both cubes
                cubeA.userData.collisionCount++;
                cubeB.userData.collisionCount++;

                // Cull the cubes after reaching the max collision count
                if (cubeA.userData.collisionCount >= MAX_COLLISIONS) {
                    scene.remove(cubeA);
                    cubes.splice(cubes.indexOf(cubeA), 1);
                }
                if (cubeB.userData.collisionCount >= MAX_COLLISIONS) {
                    scene.remove(cubeB);
                    cubes.splice(cubes.indexOf(cubeB), 1);
                }

                collisionCounts.set(collisionPoint.toArray().join(','), (collisionCounts.get(collisionPoint.toArray().join(',')) || 0) + 1);

                if (collisionCounts.get(collisionPoint.toArray().join(',')) >= COLLISION_THRESHOLD) {
                    cullCubes(collisionPoint, CULL_RADIUS);
                    collisionCounts.set(collisionPoint.toArray().join(','), 0);  // Reset after culling
                }

                // Spawn blended color cube
                spawnCubeAtPosition(collisionPoint, newColor);

                swapVelocities(cubeA, cubeB);  // Swap velocities

                collisionCooldowns.set(collisionKey, currentTime);
            }
        }

        // Helper function to swap velocities between two cubes
        function swapVelocities(cubeA, cubeB) {
            const tempVelocity = cubeA.userData.velocity.clone();
            cubeA.userData.velocity.copy(cubeB.userData.velocity);
            cubeB.userData.velocity.copy(tempVelocity);
        }

        // Check for cube collisions using the new trackCollision function
        function checkCollisions() {
            const currentTime = Date.now();
            for (let i = 0; i < cubes.length; i++) {
                for (let j = i + 1; j < cubes.length; j++) {
                    const cubeA = cubes[i];
                    const cubeB = cubes[j];
                    trackCollision(cubeA, cubeB);  // Track collision between cubes
                }
            }
        }

        // Update cube positions with bounds
        function updateCubes() {
            cubes.forEach(cube => {
                cube.position.add(cube.userData.velocity);

                // Boundary checks
                if (cube.position.x > 49.5 || cube.position.x < -49.5) {
                    cube.userData.velocity.x *= -1;
                }
                if (cube.position.z > 49.5 || cube.position.z < -49.5) {
                    cube.userData.velocity.z *= -1;
                }
            });

            checkCollisions();
        }

        // Function to start and spawn 25 random cubes
        function start() {
            for (let i = 0; i < 25; i++) {
                const x = (Math.random() - 0.5) * 100;  // Random position within the plane
                const z = (Math.random() - 0.5) * 100;
                spawnCubeAtPosition(new THREE.Vector3(x, 0, z), getRandomColor());
            }
        }

        // Render loop
        function animate() {
            requestAnimationFrame(animate);
            updateCubes();
            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener("resize", () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

        // Call the start function to spawn 25 cubes
        start();
    </script>
</body>
</html>
